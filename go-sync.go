package main

import (
	"crypto/sha256"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"
)

// --- 1. Define Structures ---

// FileInfo holds the essential metadata for a file.
type FileInfo struct {
	Path     string
	Size     int64
	ModTime  time.Time
	Checksum string
}

// SyncAction defines the operation to be performed.
type SyncAction struct {
	Action     string // "COPY", "DELETE", "SKIP"
	SourcePath string
	DestPath   string
}

// --- 2. Utility Functions ---

// calculateChecksum computes the SHA256 hash of a file.
func calculateChecksum(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", hash.Sum(nil)), nil
}

// copyFile copies a file from src to dst, creating parent directories if needed.
func copyFile(src, dst string) error {
	// 1. Ensure the destination directory exists
	if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", filepath.Dir(dst), err)
	}

	// 2. Open source file
	source, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("failed to open source file %s: %w", src, err)
	}
	defer source.Close()

	// 3. Create destination file
	destination, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("failed to create destination file %s: %w", dst, err)
	}
	defer destination.Close()

	// 4. Copy the content
	_, err = io.Copy(destination, source)
	if err != nil {
		return fmt.Errorf("failed to copy content: %w", err)
	}

	// 5. Sync (flush) data to stable storage
	if err := destination.Sync(); err != nil {
		return fmt.Errorf("failed to sync destination file: %w", err)
	}
	return nil
}

// --- 3. Core Logic ---

// BuildFileMap traverses a directory and collects metadata.
func BuildFileMap(root string) (map[string]FileInfo, error) {
	fileMap := make(map[string]FileInfo)

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("Error accessing path %q: %v\n", path, err)
			return err
		}

		if info.IsDir() {
			return nil // Skip directories
		}

		// Get relative path for comparison with the destination
		relPath, _ := filepath.Rel(root, path)

		// Calculate checksum
		checksum, err := calculateChecksum(path)
		if err != nil {
			fmt.Printf("Error calculating checksum for %s: %v\n", path, err)
			return err
		}

		fileMap[relPath] = FileInfo{
			Path:     path,
			Size:     info.Size(),
			ModTime:  info.ModTime(),
			Checksum: checksum,
		}
		return nil
	})

	return fileMap, err
}

// BuildSyncPlan compares two file maps and generates a list of required actions.
func BuildSyncPlan(sourceMap, destMap map[string]FileInfo, sourceDir, destDir string) []SyncAction {
	var plan []SyncAction

	// A. Check for files to COPY (new or modified)
	for relPath, sourceInfo := range sourceMap {
		destInfo, exists := destMap[relPath]
		destPath := filepath.Join(destDir, relPath)

		if !exists {
			// File exists in source but not in destination -> COPY
			plan = append(plan, SyncAction{Action: "COPY", SourcePath: sourceInfo.Path, DestPath: destPath})
			fmt.Printf("[PLAN] + ADD: %s\n", relPath)
		} else {
			// Check if source is newer or content is different
			isSourceNewer := sourceInfo.ModTime.After(destInfo.ModTime)
			isChecksumDifferent := sourceInfo.Checksum != destInfo.Checksum

			if isSourceNewer || isChecksumDifferent {
				// Modified file -> COPY (Overwrite)
				plan = append(plan, SyncAction{Action: "COPY", SourcePath: sourceInfo.Path, DestPath: destPath})
				fmt.Printf("[PLAN] ~ MOD: %s (Source Newer: %t, Checksum Diff: %t)\n", relPath, isSourceNewer, isChecksumDifferent)
			} else {
				// Identical -> SKIP
				// fmt.Printf("[PLAN] = SKIP: %s\n", relPath)
			}
		}
	}

	// B. Check for files to DELETE (in destination but not in source)
	for relPath := range destMap {
		if _, exists := sourceMap[relPath]; !exists {
			// File exists in destination but not in source -> DELETE
			destPath := filepath.Join(destDir, relPath)
			plan = append(plan, SyncAction{Action: "DELETE", DestPath: destPath})
			fmt.Printf("[PLAN] - DEL: %s\n", relPath)
		}
	}

	return plan
}

// ExecutePlan performs the actions generated by BuildSyncPlan.
func ExecutePlan(plan []SyncAction) error {
	fmt.Println("\n--- Executing Sync Plan ---")
	for _, action := range plan {
		switch action.Action {
		case "COPY":
			fmt.Printf("COPY: %s -> %s\n", action.SourcePath, action.DestPath)
			if err := copyFile(action.SourcePath, action.DestPath); err != nil {
				return fmt.Errorf("copy failed for %s: %w", action.SourcePath, err)
			}
		case "DELETE":
			fmt.Printf("DELETE: %s\n", action.DestPath)
			if err := os.Remove(action.DestPath); err != nil {
				return fmt.Errorf("delete failed for %s: %w", action.DestPath, err)
			}
		case "SKIP":
			// No action needed
		}
	}
	return nil
}

// --- 4. Main Execution ---

func main() {
	// Define your source and destination directories
	// NOTE: You should ensure these directories exist before running
	sourceDir := "source_data"
	destDir := "destination_data"

	// 1. Ensure directories exist for the demo
	if err := os.MkdirAll(sourceDir, 0755); err != nil {
		fmt.Printf("Failed to create source directory: %v\n", err)
		return
	}
	if err := os.MkdirAll(destDir, 0755); err != nil {
		fmt.Printf("Failed to create destination directory: %v\n", err)
		return
	}

	// 2. Build maps (pre-sync phase)
	fmt.Println("--- Building Source Map ---")
	sourceMap, err := BuildFileMap(sourceDir)
	if err != nil {
		fmt.Printf("Error building source map: %v\n", err)
		return
	}

	fmt.Println("--- Building Destination Map ---")
	destMap, err := BuildFileMap(destDir)
	if err != nil {
		fmt.Printf("Error building destination map: %v\n", err)
		return
	}

	// 3. Build the sync plan
	fmt.Println("\n--- Building Sync Plan (rsync-like dry run) ---")
	plan := BuildSyncPlan(sourceMap, destMap, sourceDir, destDir)
	fmt.Printf("\nGenerated Plan: %d actions\n", len(plan))

	// 4. Execute the plan
	if len(plan) > 0 {
		if err := ExecutePlan(plan); err != nil {
			fmt.Printf("\nSync execution FAILED: %v
